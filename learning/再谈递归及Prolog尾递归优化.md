# 再谈递归及Prolog尾递归优化

### 斐波那契数列递归求解
递归指的是函数自己调用自己的行为。我们用斐波那契数列的前五项求值来说明递归调用的过程

Prolog求斐波那契数列的第N项，显得格外优雅，你只需要定义好基本的关系和求解的规则约束即可。

斐波那契数列存在两项基本关系，即第一项和第二项的值为1，描述如下

```
fibonacci(1, 1).
fibonacci(2, 1).
```

含义为第1项的斐波那契数列值为1；第二项的斐波那契数列值为1

那么求解斐波那契第N项的规则约束如下描述：

**第N项的斐波那契值等于第N - 1项与第N - 2项斐波那契值之和。** 那么我们首先要用Prolog描述第N - 1项是哪一项、第N - 2项是哪一项、第N - 1项对应的值是多少、第N - 2项对应的值是多少、以及最终的结果是多少.这些规则约束用Prolog描述如下

```
fibonacci(No, Value) :- 
    No > 2, No1 is No - 1, No2 is No - 2, fibonacci(No1, Value1), fibonacci(No2, Value2), Value is Value1 + Value2.
```

含义为当项数No大于2(即从第三项开始)时，第N - 1项的项数为No - 1(用No1表示),第N - 2项的项数为No - 2(用No2表示),第No1项的斐波那契值为fibonacci(No1, Value1),第No2项的斐波那契值为fibonacci(No2, Value2),这两个表达式会返回Value1与Value2的值，那么最终的结果就是Value = Value1 + Value2.

**从这里我们也可以看到，对Prolog表达式的调用，总是输入常量值返回变量值。**

测试如下

```
?- fibonacci(1, Vlaue).
Vlaue = 1 ;
false.

?- fibonacci(2, Value).
Value = 1 ;
false.

?- fibonacci(3, Value).
Value = 2 ;
false.

?- fibonacci(4, Value).
Value = 3 ;
false.

?- fibonacci(5, Value).
Value = 5 ;
false.
```

那么我们这里当No为1和2时，相当于直接查询关系，即直接返回1。而当No > 2时，则会调用规则约束下的结果事实，通过规则约束推理目标关系

我们以斐波那契的第五项来说明递归调用的过程，如下

![递归调用](https://feily.tech/image/20190204115236.png)

可以看出，我们要求第5项斐波那契值，那么就需要知道第4项和第3项的值，而要知道第3项的值，我们就要先知道第2项和第一项的值，要知道第4项的值就要先知道第3项和第2项的值。

可见，递归调用的前提就是规则通用，即除过特殊项，每项的求解规则都是一致的，那么就可以自己调用自己，即递归来完成求解过程；由于函数的调用是不断入栈和出栈的过程，即调用一个函数就等于入栈一次调用函数，等该函数调用完毕再出栈，那么上述斐波那契的调用栈如下图所示

![递归调用](https://feily.tech/image/20190204123324.png)

图中标号指明了入栈顺序，可见求一个第五项，我们需要九次递归调用且全部入栈，这是很耗费栈空间的，很容易发生栈溢出。我们也发现了，里面存在很多不必要的调用，比如同一个项我们计算了多次，这是因为一般情况下递归调用并不保存计算的中间结果。所以如果我们不注意就滥使用递归的话，很容易栈溢出。

### Prolog中的尾递归优化

从上图可以看出，递归调用中，先入栈的函数与后入栈的函数存在依赖关系，因为先入栈函数计算的进行必须需要后入栈的计算结果，而后入栈的函数又与后后入栈的函数存在依赖关系，形象地说递归调用就相当于一颗树，呈指数级增长，普通的递归调用明显会造成栈溢出，那么采用尾递归进行优化就会解决这个问题。

尾递归是怎样的思路呢？它的目的就是打破递归调用中函数间的依赖关系，从而使得栈空间的耗费呈线性关系而非指数关系，这样就不会发生栈溢出的问题。具体而言就是利用函数返回值的特性，因为函数返回值返回之后该函数就可以出栈，也就是该函数不会继续占用栈空间，那么一个函数尾递归就意味着该函数的返回值是一个函数，即当前函数返回自己后然后出栈

尾递归具体操作的解释稍显抽象，我们先从普通递归改写尾递归的方法开始说起。以求阶乘为例，普通递归法的伪码表示如下

int factorial(int n) {
    if (n == 1) return 1;
	return n * factorial(n - 1);
}

这样假如我们计算5的阶乘，那么调用过程如下

```
n = 5时，得到5 * factorial(4)
                 n = 4时，得到4 * factorial(3)
		                          n = 3时，得到3 * factorial(2)
								                   n = 2时，得到2 * factorial(1) = 2 * 1 = 2
那么最终结果就是5 * 4 * 3 * 2 * 1 = 120
```

可见，需要四次递归才能得到n = 2的值，然后依次退栈四次才能得到n = 5时的值。随着n的增大，那么就是指数级增长。因为函数间存在依赖关系

普通递归对随着n的增大，需要的空间越来越大，必然会栈溢出。我们将其改造一下，变成尾递归的形式，如下

int factorial(int n, int total) {
    if (n == 1) return total;
	return factorial(n - 1, n * total);
}

```
那么尾递归的调用过程如下,total初值为1，因为是计算乘法(阶乘)，初始值不能为0
调用factorial(5, 1)，得到factorial(4, 5 * 1)
第一步的计算结果就是factorial(4, 5 * 1)，没有任何依赖关系
然后计算factorial(4, 5 * 1)，得到factorial(3, 4 * 5 * 1)
第二步的计算结果就是factorial(3, 4 * 5 * 1)
然后计算factorial(3, 4 * 5 * 1)，得到factorial(2, 3 * 4 * 5 * 1)
第三步的计算结果是factorial(2, 3 * 4 * 5 * 1)，得到factorial(1, 2 * 3 * 4 * 5 * 1)
然后计算factorial(1, 2 * 3 * 4 * 5 * 1)，得到最终结果就是2 * 3 * 4 * 5 * 1 = 120
```

我们通过观察可以发现，真正的计算逻辑是在函数的最后一个参数，第一个参数只是控制计算的次数，次数是递减的，即当次数递减到判断语句中的情况时那么就返回最后一个形参的值，而最后一个形参则是正儿八经的计算逻辑

阶乘的计算逻辑很容易理解，随着n的递减然后相乘，斐波那契数列的又怎么样呢？我们先看看斐波那契数列的普通递归的伪码表示

```
int fibonacci(int n) {
    if (n == 0) return 0;
	if (n == 1 || n == 2) return 1;
	return fibonacci(n - 1) + fibonacci(n - 2);
}
```

具体就不解释了，其普通递归的栈空间上面图片说的很清楚。我们将其改造为尾递归的形式，即返回值为函数自身，总之，众多形参中必然有一个控制次数，一个为具体的计算逻辑也是返回结果，其余形参为计算逻辑中的其余参数如下

```
int fibonacci(int n, int ret1, int ret2) {
    if (n == 1) return ret1;
	return fibonacci(n - 1, ret2, ret1 + ret2);
}
```

我们具体看一下尾递归的过程，如下

```
当n = 5时，函数调用为fibonacci(5, 0, 1)，返回值为fibonacci(4, 1, 1);
第一步计算完毕，不必保留，直接计算fibonacci(4, 1, 1)，此时n = 4(5 - 1 = 4), ret1 = 1(ret1等于上一个函数的ret2), ret2 = 1(ret2等于上一个函数的ret1 + ret2)

当n = 4时，函数调用为fibonacci(4, 1, 1)，返回值为fibonacci(3, 1, 2)；
第二步计算完毕，不必保留，直接计算fibonacci(3, 1, 2)，此时n = 3(4 - 1 = 3), ret1 = 1(ret1等于上一个函数的ret2), ret2 = 2(ret2等于上一个函数的ret1 + ret2)

当n = 3时，函数调用为fibonacci(3, 1, 2)，返回值为fibonacci(2, 2, 3);
第三步计算完毕，不必保留，直接计算fibonacci(2, 2, 3)，此时n = 2(3 - 1 = 2), ret1 = 2(ret1等于上一个函数的ret2), ret2 = 3(ret2等于上一个函数的ret1 + ret2)

当n = 2时，函数调用为fibonacci(2, 2, 3)，返回值为fibonacci(1, 3, 5)；
第四步计算完毕，不必保留，直接计算fibonacci(1, 3, 5)，此时n = 1(2 - 1 = 1), ret1 = 3(ret1等于上一个函数的ret2), ret2 = 5(ret2等于上一个函数的ret1 + ret2)

当n = 1时，进入判断语句，直接返回上一步的ret2，即5
```

其实，如果你细心的话，我们已经发现有趣的地方了，这也是尾递归的本质，即次数控制是递减的，但是计算顺序还是递增的。听不懂？没关系，我们看一张表格就明白了

|No.n|No.n-1|No.n-2|Value|
|------|------|------|------|
|0|——|——|0|
|1|——|——|1|
|2|——|——|1|
|3|No.2|No.1|2|
|4|No.3|No.2|3|
|5|No.4|No.3|5|

上面是普通递归的结果变化，随着No.n的增加，Value值也会增加，其实，说白了，No.n就是用来控制次数的，Value不过是一定次数(No.n)下的数列值，只要不影响计算的次数那么No.n怎样写都可以，当然也可以倒着写，如下

|No.n|No.n-1|No.n-2|Value|
|------|------|------|------|
|5|——|——|0|
|4|——|——|1|
|3|——|——|1|
|2|No.2|No.1|2|
|1|No.3|No.2|3|
|0|No.4|No.3|5|

对吧，仍然是循环计算了5次的结果(不算No.0)，尾递归用的就是这种方法，尾递归强化形参中的控制次数的参数的概念，而忽略第几项的概念，重视了value值得真正意义。如果我们把尾递归计算斐波那契的方法用表格列出来，那么和上表一模一样。

这就是尾递归，总结一下

**尾递归在形式上是将自身作为返回值返回，参数上其中包括控制递归次数的形参和真正计算逻辑的形参，其余形参均为计算逻辑的形参服务，在本质上就是强化结果的作用，显化控制次数的作用*

次数时从后往前，而结果是从前往后